---
title: "Report_10883408"
author: '10883408'
date: "2024-04-08"
output: pdf_document
---

```{r part A, echo=FALSE}

library(ggplot2)

earthquake <- read.table(file = "earthquake.txt", header = TRUE, sep = "", dec = ".")


# Visualizing the data
ggplot(earthquake, aes(x=body, y=surface, color=type, shape=type)) +
  geom_point(size=3) +
  theme_minimal() +
  labs(title = "Body-wave Magnitude vs. Surface-wave Magnitude",
       x = "Body-wave Magnitude (mb)",
       y = "Surface-wave Magnitude (Ms)",
       color = "Type",
       shape = "Type") +
  scale_color_manual(values = c("equake" = "blue", "explosn" = "red")) +
  geom_smooth(method = "lm", se = FALSE, aes(group=type), color="black") 

```



```{r }
# Load necessary libraries
library(randomForest)
library(ggplot2)
library(caret)


data <- read.table(file = "earthquake.txt", header = TRUE, sep = "", dec = ".")
# 2. Preprocess the data (ensure correct data types)
data$type <- as.factor(data$type)

# 3. For hyperparameter tuning, normally you'd create a train-test split or use cross-validation.
# Since we're evaluating with leave-one-out cross-validation later, we'll skip splitting here.

# 4. Train the Random Forest model
# Perform a grid search for hyperparameter tuning (example: mtry)
# For simplicity, we'll skip the tuning part and use default parameters here
set.seed(123) # For reproducibility
rf_model <- randomForest(type ~ body + surface, data=data)

# 5. Model visualization
# Predict on a grid to visualize decision boundaries
plot_data <- with(data, expand.grid(body=seq(min(body), max(body), length.out=100),
                                    surface=seq(min(surface), max(surface), length.out=100)))
plot_data$type <- predict(rf_model, newdata=plot_data, type="class")

ggplot(data, aes(x=body, y=surface, color=type)) +
  geom_point() +
  geom_point(data=plot_data, aes(x=body, y=surface, color=type), alpha=0.5) +
  labs(title="Random Forest Decision Boundary with Data Points")

```

