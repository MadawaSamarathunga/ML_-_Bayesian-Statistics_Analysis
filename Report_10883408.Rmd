---
title: "Report_10883408"
author: '10883408'
date: "2024-04-08"
output:
  pdf_document: 
   latex_engine: xelatex
  word_document: default
editor_options:
  chunk_output_type: console
---


```{r loadlib, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
library(caret)
library(randomForest)
library(ggplot2)
library(dplyr)
library(e1071)
library(rpart)
library(rpart.plot)
library(RColorBrewer)
```

## ML part A 
```{r part A, echo=FALSE}

earthquake <- read.table(file = "earthquake.txt", header = TRUE, sep = "", dec = ".")
data <- read.table(file = "earthquake.txt", header = TRUE, sep = "", dec = ".")

ggplot(earthquake, aes(x=body, y=surface, color=type)) +
  geom_point(size=2, alpha=0.8, shape=19) + theme_light(base_size = 12) +
  labs(title = "Body-wave Magnitude vs. Surface-wave Magnitude",subtitle = "Comparing earthquake types",
       x = "Body-wave Magnitude (mb)",
       y = "Surface-wave Magnitude (Ms)",
       color = "Type") +
  scale_color_brewer(palette = "Set1") +theme(legend.position = "right")

```

```{r echo=FALSE}
library(ggplot2)

ggplot(data, aes(x = type, y = body, fill = type)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5, color = "darkgray") +
  labs(title = "Box Plot with Jitter of Body-Wave Magnitude by Type",
       x = "Type",
       y = "Body-Wave Magnitude (mb)") +
  theme_minimal()

```

```{r echo=FALSE}

library(ggplot2)

ggplot(data, aes(x = type, y = surface, fill = type)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5, color = "darkgray") +
  labs(title = "Box Plot with Jitter of Surface-Wave Magnitude by Type",
       x = "Type",
       y = "Surface-Wave Magnitude (Ms)") +
  theme_minimal()

```


## ML part B

```{r part B(random forest), echo=FALSE}

library(randomForest)
library(caret)
library(ggplot2)

data <- read.table(file = "earthquake.txt", header = TRUE, sep = "", dec = ".")

data$type <- as.factor(data$type)

# Split the data into training and testing sets
set.seed(123) # for reproducibility
trainIndex <- createDataPartition(data$type, p=0.8, list=FALSE)
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]

# Train the Random-forest model
control <- trainControl(method="cv", number=5) # 5-fold cross-validation
tuneGrid <- expand.grid(mtry=c(1,2)) # Tuning the 'mtry' parameter
rfModel <- train(type ~ body + surface, data=trainData, method="rf",
                 trControl=control, tuneGrid=tuneGrid)

# Model visualization
# Creating a grid to cover the range of body and surface values
surfaceRange <- range(data$surface)
bodyRange <- range(data$body)
grid <- expand.grid(body=seq(from=bodyRange[1], to=bodyRange[2], length.out=100),
                    surface=seq(from=surfaceRange[1], to=surfaceRange[2], length.out=100))

# Predicting over the grid
grid$prediction <- predict(rfModel, newdata=grid)

# Plotting with corrected data reference for geom_point

ggplot() +
  geom_tile(data = grid, aes(x = body, y = surface, fill = prediction), alpha = 0.5) +
  geom_point(data = data, aes(x = body, y = surface, color = type), size = 3, alpha = 0.6) +
  scale_fill_brewer(palette = "Set1", name = "Predicted Type") +
  scale_color_brewer(palette = "Set2", name = "Actual Type") +
  labs(title = "Earthquake vs. Nuclear Explosion Prediction",
       subtitle = "Random Forest Model Predictions vs. Actual Data",
       x = "Body-Wave Magnitude (mb)",
       y = "Surface-Wave Magnitude (Ms)",
       fill = "Predicted Type",
       color = "Actual Type") +
  theme_minimal() +
  theme(legend.position = "right",
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 12),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10)) +
  guides(fill = guide_legend(override.aes = list(alpha = 1)),
         color = guide_legend(override.aes = list(alpha = 1)))

```

### error rate
```{r}
# Extract the Random Forest model from the caret object
rf <- rfModel$finalModel

# Error rate plot
plot(rf$err.rate[, "OOB"], type = "l", col = "red",
     xlab = "Number of Trees",
     ylab = "OOB Error Rate",
     main = "OOB Error Rate vs. Number of Trees")

```


```{r echo=FALSE}
library(e1071)
library(caret)
library(ggplot2)

# Load the dataset
data <- read.table("earthquake.txt", header = TRUE)

# Check for missing values and remove them
data <- na.omit(data)

# Encode factors as numeric
data$type <- as.factor(data$type)

# Split the data into predictors and response
predictors <- data[, c("body", "surface")]
response <- data$type

# Define the tuning grid
tune.grid <- expand.grid(sigma = 10^(-3:-1), C = 10^(1:3))

# Define training control
train.control <- trainControl(method = "cv", number = 10, classProbs = TRUE)

# Train the SVM model
set.seed(123)
svm.model <- train(x = predictors, y = response, method = "svmRadial",
                   preProcess = c("center", "scale"),
                   trControl = train.control, tuneGrid = tune.grid)

# Best model parameters
best.parameters <- svm.model$bestTune

# Create a grid over the range of the data
body_seq <- seq(from = min(data$body), to = max(data$body), length.out = 100)
surface_seq <- seq(from = min(data$surface), to = max(data$surface), length.out = 100)
grid <- expand.grid(body = body_seq, surface = surface_seq)

# Predict on the grid to visualize the decision boundary
grid$prediction <- predict(svm.model, newdata = grid)

# Create the SVM plot
svm.plot <- ggplot() +
  geom_tile(data = grid, aes(x = body, y = surface, fill = as.factor(prediction)), alpha = 0.2) +
  geom_point(data = data, aes(x = body, y = surface, color = type)) +
  scale_color_manual(values = c("red", "blue")) +
  scale_fill_manual(values = c("lightpink", "lightblue")) +
  labs(color = "Actual Type", fill = "Predicted Type") +
  ggtitle("SVM Classification of Earthquake and Nuclear Explosions")

# Print the plot
print(svm.plot)

# Print the best parameters
print(best.parameters)



```
# Part D

```{r echo=FALSE}
library(ggplot2)

# Load the dataset
data <- read.table("earthquake.txt", header = TRUE)

# Extract just the body and surface variables for clustering
clustering_data <- data[, c("body", "surface")]

# Determine the total within sums of squares for a range of number of clusters
wss <- (nrow(clustering_data) - 1) * sum(apply(clustering_data, 2, var))
for (i in 2:10) {
  wss[i] <- sum(kmeans(clustering_data, centers = i, nstart = 20)$withinss)
}

# Elbow method plot to find optimal number of clusters
plot(1:10, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")

# Apply K-means clustering with different numbers of clusters
for (k in 2:4) {
  set.seed(123) # Set seed for reproducibility
  cluster <- kmeans(clustering_data, centers = k, nstart = 20)
  data$cluster <- as.factor(cluster$cluster)

  # Plot the clusters
  p <- ggplot(data, aes(x = body, y = surface, color = cluster)) +
    geom_point(alpha = 0.5) +
    scale_color_brewer(palette = "Dark2") +
    labs(title = paste("K-means Clustering with", k, "Clusters"),
         x = "Body-Wave Magnitude (mb)",
         y = "Surface-Wave Magnitude (Ms)",
         color = "Cluster") +
    theme_minimal()

  # Print the plot in RStudio
  print(p)
}


```





